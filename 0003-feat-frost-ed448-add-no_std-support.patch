From aa71b48da41056675596c7e062b22de4a095dec5 Mon Sep 17 00:00:00 2001
From: StackOverflowExcept1on
 <109800286+StackOverflowExcept1on@users.noreply.github.com>
Date: Fri, 29 Aug 2025 18:30:39 +0300
Subject: [PATCH] feat(frost-ed448): add `#![no_std]` support

---
 .github/workflows/main.yml           |  3 +--
 frost-core/CHANGELOG.md              |  2 ++
 frost-ed448/Cargo.toml               |  2 +-
 frost-ed448/src/lib.rs               | 31 ++++++++++++++--------------
 frost-ed448/src/tests/deserialize.rs |  6 +++---
 5 files changed, 23 insertions(+), 21 deletions(-)

diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
index 16d59a0..77f6a63 100644
--- a/.github/workflows/main.yml
+++ b/.github/workflows/main.yml
@@ -60,10 +60,9 @@ jobs:
   build_no_std:
     name: build with no_std
     runs-on: ubuntu-latest
-    # Skip ed448 which does not support it.
     strategy:
       matrix:
-        crate: [ristretto255, ed25519, p256, secp256k1, secp256k1-evm, secp256k1-tr, rerandomized]
+        crate: [ed448, ristretto255, ed25519, p256, secp256k1, secp256k1-evm, secp256k1-tr, rerandomized]
     steps:
     - uses: actions/checkout@v4.2.2
     - uses: dtolnay/rust-toolchain@master
diff --git a/frost-core/CHANGELOG.md b/frost-core/CHANGELOG.md
index 995fc97..8ff024f 100644
--- a/frost-core/CHANGELOG.md
+++ b/frost-core/CHANGELOG.md
@@ -6,6 +6,8 @@ Entries are listed in reverse chronological order.
 
 * Added a new ciphersuite `frost-secp256k1-evm` that uses the secp256k1
   elliptic curve with hash keccak256.
+* Added no-std support for frost-ed448 crate. This became possible after migration to `ed448-goldilocks-plus` (fork of
+  `ed448-goldilocks`).
 
 ## 2.2.0
 
diff --git a/frost-ed448/Cargo.toml b/frost-ed448/Cargo.toml
index 4d834fe..79bbc6e 100644
--- a/frost-ed448/Cargo.toml
+++ b/frost-ed448/Cargo.toml
@@ -17,7 +17,7 @@ rustdoc-args = ["--cfg", "docsrs"]
 
 [dependencies]
 document-features.workspace = true
-ed448-goldilocks = { version = "0.9.0" }
+ed448-goldilocks-plus = { version = "0.16", features = ["zeroize"], default-features = false }
 frost-core.workspace = true
 frost-rerandomized.workspace = true
 rand_core.workspace = true
diff --git a/frost-ed448/src/lib.rs b/frost-ed448/src/lib.rs
index 2acc590..1ee8e0b 100644
--- a/frost-ed448/src/lib.rs
+++ b/frost-ed448/src/lib.rs
@@ -1,3 +1,4 @@
+#![no_std]
 #![allow(non_snake_case)]
 #![deny(missing_docs)]
 #![cfg_attr(docsrs, feature(doc_auto_cfg))]
@@ -9,9 +10,8 @@ extern crate alloc;
 
 use alloc::collections::BTreeMap;
 
-use ed448_goldilocks::{
-    curve::{edwards::CompressedEdwardsY, ExtendedPoint},
-    Scalar,
+use ed448_goldilocks_plus::{
+    CompressedEdwardsY, EdwardsPoint, Scalar, ScalarBytes, WideScalarBytes,
 };
 use frost_rerandomized::RandomizedCiphersuite;
 use rand_core::{CryptoRng, RngCore};
@@ -44,11 +44,11 @@ impl Field for Ed448ScalarField {
     type Serialization = [u8; 57];
 
     fn zero() -> Self::Scalar {
-        Scalar::zero()
+        Scalar::ZERO
     }
 
     fn one() -> Self::Scalar {
-        Scalar::one()
+        Scalar::ONE
     }
 
     fn invert(scalar: &Self::Scalar) -> Result<Self::Scalar, FieldError> {
@@ -64,11 +64,11 @@ impl Field for Ed448ScalarField {
     }
 
     fn serialize(scalar: &Self::Scalar) -> Self::Serialization {
-        scalar.to_bytes_rfc_8032()
+        scalar.to_bytes_rfc_8032().into()
     }
 
     fn deserialize(buf: &Self::Serialization) -> Result<Self::Scalar, FieldError> {
-        match Scalar::from_canonical_bytes(*buf) {
+        match Scalar::from_canonical_bytes(ScalarBytes::from_slice(buf)).into() {
             Some(s) => Ok(s),
             None => Err(FieldError::MalformedScalar),
         }
@@ -86,20 +86,20 @@ pub struct Ed448Group;
 impl Group for Ed448Group {
     type Field = Ed448ScalarField;
 
-    type Element = ExtendedPoint;
+    type Element = EdwardsPoint;
 
     type Serialization = [u8; 57];
 
     fn cofactor() -> <Self::Field as Field>::Scalar {
-        Scalar::one()
+        Scalar::ONE
     }
 
     fn identity() -> Self::Element {
-        Self::Element::identity()
+        Self::Element::IDENTITY
     }
 
     fn generator() -> Self::Element {
-        Self::Element::generator()
+        Self::Element::GENERATOR
     }
 
     fn serialize(element: &Self::Element) -> Result<Self::Serialization, GroupError> {
@@ -111,11 +111,11 @@ impl Group for Ed448Group {
 
     fn deserialize(buf: &Self::Serialization) -> Result<Self::Element, GroupError> {
         let compressed = CompressedEdwardsY(*buf);
-        match compressed.decompress() {
+        match compressed.decompress_unchecked().into_option() {
             Some(point) => {
                 if point == Self::identity() {
                     Err(GroupError::InvalidIdentityElement)
-                } else if point.is_torsion_free() {
+                } else if point.is_torsion_free().into() {
                     // decompress() does not check for canonicality, so we
                     // check by recompressing and comparing
                     if point.compress().0 != compressed.0 {
@@ -144,8 +144,9 @@ fn hash_to_array(inputs: &[&[u8]]) -> [u8; 114] {
 }
 
 fn hash_to_scalar(inputs: &[&[u8]]) -> Scalar {
-    let output = hash_to_array(inputs);
-    Scalar::from_bytes_mod_order_wide(&output)
+    let temp = hash_to_array(inputs);
+    let output = WideScalarBytes::from_slice(&temp);
+    Scalar::from_bytes_mod_order_wide(output)
 }
 
 /// Context string from the ciphersuite in the [spec]
diff --git a/frost-ed448/src/tests/deserialize.rs b/frost-ed448/src/tests/deserialize.rs
index 6c86b77..e887334 100644
--- a/frost-ed448/src/tests/deserialize.rs
+++ b/frost-ed448/src/tests/deserialize.rs
@@ -1,10 +1,10 @@
 use crate::*;
-use ed448_goldilocks::curve::ExtendedPoint;
+use ed448_goldilocks_plus::EdwardsPoint;
 use frost_core::Ciphersuite;
 
 #[test]
 fn check_deserialize_non_canonical() {
-    let mut encoded_generator = ExtendedPoint::generator().compress().0;
+    let mut encoded_generator = EdwardsPoint::GENERATOR.compress().0;
 
     let r = <Ed448Shake256 as Ciphersuite>::Group::deserialize(&encoded_generator);
     assert!(r.is_ok());
@@ -35,7 +35,7 @@ fn check_deserialize_non_prime_order() {
 
 #[test]
 fn check_deserialize_identity() {
-    let encoded_identity = ExtendedPoint::identity().compress().0;
+    let encoded_identity = EdwardsPoint::IDENTITY.compress().0;
 
     let r = <Ed448Shake256 as Ciphersuite>::Group::deserialize(&encoded_identity);
     assert_eq!(r, Err(GroupError::InvalidIdentityElement));
-- 
2.50.1

